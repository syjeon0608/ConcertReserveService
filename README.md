
# 대기열 고도화 with Redis
RDBMS로 대기열을 구축하면 대기열 진입 요청부터 과도한 DB 부하가 발생하여 서버 부하를 줄이려는 목적이 퇴색될 수 있다. RDBMS는 디스크 기반 저장소이므로 대규모의 빠른 읽기 및 쓰기 요청에 병목 현상이 발생하기 쉽고, 트랜잭션 관리와 복잡한 쿼리 기능이 오히려 대기열의 단순한 데이터 처리에 불필요한 부하를 줄 수 있다.

반면, Redis는 메모리 기반의 초고속 데이터 처리가 가능하여 대기열 요청이 급증해도 안정적으로 작동할 수 있다. Redis는 다양한 자료구조를 지원해 사용자 순서를 효율적으로 관리할 수 있으며, TTL 기능을 통해 오래된 데이터를 자동으로 삭제하여 메모리 사용을 최적화할 수 있다. 이를 통해 Redis는 초당 수만 건의 요청에도 성능 저하 없이 빠르게 응답할 수 있다.

### RDBMS vs Redis

1. **테스트 요약 및 조건**
- **테스트 목적**: Redis와 JPA를 각각 사용하여 대기열 조회 API의 성능을 측정하고, 각 데이터 접근 방식이 제공하는 응답 속도와 처리 효율성, 그리고 대량 요청 상황에서의 안정성을 비교하였다.
- **테스트 환경**: 동시 사용자(VUs) 100명, 지속 시간 60초
- **측정 항목**: 평균 응답 시간, 최대 응답 시간, 퍼센타일 응답 시간(90%, 95%), 초당 처리량, 요청 실패율

**Jpa**<br/>
<img width="855" alt="redis4" src="https://github.com/user-attachments/assets/7f60a3ef-3ec7-44c2-8e1a-96d68ca00f3b"><br/>
**Redis**<br/>
<img width="825" alt="jpa4" src="https://github.com/user-attachments/assets/add680c2-fa05-4e69-808b-3d8a912b8f77"><br/>







2. **성능 결과 요약**

| 항목 | Jpa | **Redis**  |
| --- | --- | --- |
| 평균 HTTP 요청완료시간http_req_duration | 24.43 ms | 7.5 ms |
| 90번째 백분위수 응답 시간 | 42.75 ms | 13.49 ms |
| 95번째 백분위수 응답 시간 | 52.56 ms | 18.43 ms |
| HTTP요청 대기 시간 http_req_waiting | 24.3 ms | 7.25 ms |
| 초당 요청 처리량 (TPS) | 97.50 요청/초 | 99.09 요청/초 |

테스트 결과 JPA는 평균 응답 시간이 24.43ms로 Redis의 7.5ms보다 느리며, 대규모 트래픽 상황에서 응답 시간의 변동이 큰 편이다. 반면, Redis는 빠르고 일관된 응답 속도와 높은 처리량을 보여, 대기열과 같이 빠르고 안정적인 처리가 필요한 시스템에 적합하다. 대기열 시스템에서는 Redis를 사용해 서버 부하를 줄이고 사용자 경험을 향상할 수 있다.

3. 대기열 구현 및 Redis 전환 계획

대기열을 유량제어 방식으로 구현하려고 한다. 대기열에 있는 토큰을 일정 주기마다 일정 개수 씩 활성화하여 서버가 감당할 수 있는 범위 내에서 사용자 요청을 처리할 계획이다. 대기열 토큰이 활성화된 사용자는 이후 티켓 구매나 예약과 같은 특정 자원에 접근할 권한이 부여된다. 즉, 대기열 토큰의 역할은 오직 “인가”에 있으며, 이 토큰이 활성화되어야 사용자가 다음 단계로 진행할 수 있는 자격이 주어진다.

또한, 대기열 토큰에 대한 정보를 별도의 DB에 저장할 필요가 없다고 판단했다. 대기열 토큰은 티켓팅을 위한 일시적인 입장권에 불과하며 사용자가 티켓팅을 완료하거나 토큰의 만료 시간이 경과하면 더 이상 유의미한 정보가 아니다. 따라서 기존 JPA로 관리되던 대기열 도메인을 Redis로 이관하여 메모리 기반의 빠른 접근성과 유연한 만료 관리 기능을 활용하고자 한다. Redis는 TTL 설정을 통해 일정 시간이 지나면 자동으로 토큰을 삭제할 수 있으므로, 대기열에서 발생하는 불필요한 데이터의 처리가 간편해진다.

### 대기열 구축에 필요한 기능

- 대기열 토큰 생성
- 현재 대기순번 조회(폴링)
- 대기열 토큰 활성화
- 대기열 토큰 만료

### 대기열 구현에 사용한 알고리즘 : Sorted Set

Redis의 Sorted Set은 각 요소가 score 값을 가지고 자동으로 정렬되는 특성을 가져, 순서 기반의 대기열 시스템에 최적화되어 있다. Sorted Set을 사용하면 대기열의 사용자에게 순번을 부여하고, 순서대로 접근하도록 관리할 수 있어 별도의 정렬 작업 없이 효율적인 대기열 운영이 가능하다. 

- 대기열 진입

```jsx
ZADD waiting_queue 1697031340000 "123e4567-e89b-12d3-a456-426614174000"
```

score를 timestamp로 설정하면, 요청이 들어온 순서대로 자동 정렬되어 가장 먼저 대기열에 진입한 사용자부터 차례로 관리할 수 있다.

- 대기번호 조회

```jsx
ZRANK waiting_queue "123e4567-e89b-12d3-a456-426614174000"
```

`ZRANK`는 특정 사용자가 대기열에서 몇 번째 위치에 있는지를 조회할 수 있다. 이 명령어를 통해 사용자의 대기 순번을 효율적으로 계산할 수 있으며, 폴링 방식으로 사용자가 대기 순번을 확인할 때 매번 빠르게 순서를 조회할 수 있다.

- 토큰 활성화

```jsx
ZPOPMIN waiting_queue 10  //활성화할 토큰 개수
SET active_token:123e4567-e89b-12d3-a456-426614174000 "" PX 1200000
```

토큰 활성화는 스케줄러를 통해 일정 시간마다, 일정 개수씩 순차적으로 진행한다. `ZPOPMIN` 명령어를 사용하여 score**가 작은 순서대로 10개의 토큰을 꺼내 활성화**하며, 각각 TTL을 설정하여 SET 명령어로 저장한다. 이때 활성화된 토큰의 key는 uuid로 설정하는데, 이는 토큰의 활성화 여부만 판단하면 되기 때문에 **다른 메타정보 없이 빈 값을 사용**하였다.

- 결제후 토큰 만료

```jsx
DEL active_token:123e4567-e89b-12d3-a456-426614174000
```

TTL에 의해 자동으로 만료되기 전이라도 결제가 완료된 시점에서 토큰을 바로 삭제하여 자원을 절약할 수 있다. 결제가 완료되면 DEL 명령어를 사용해 활성화된 토큰을 즉시 삭제한다.

- 토큰 활성화 여부 검증

```jsx
EXISTS active_token:123e4567-e89b-12d3-a456-426614174000
```

EXISTS 명령어로 해당 키가 존재하는지 확인하여, 토큰이 활성화된 상태인지 검증할 수 있다. 키가 존재하면 사용자는 이후 콘서트 스케줄 조회, 예약, 결제를 진행할 수 있다.

<br/>

# 캐싱 with Redis

### **캐싱 적용 대상 분석**

캐싱을 적용할 만한 유즈케이스가 뭐가있을까?

- 콘서트 목록 조회
    - 자주 변하지 않는 데이터
    - 조회요청이 많음 (사이트 진입 시 가장 먼저 로드됨)
    - 캐싱 적합함
- 콘서트별 스케쥴 조회
    - 스케쥴 조회 시 잔여좌석 수도 함께 표시
    - 자주 바뀌는 데이터
    - 조회요청이 많음 : But 대기열로 API 요청 수 조절중
    - 데이터 정합성 중요도 (중~상) : 사용자 입장에서 잔여좌석이 10석이라 해서 기대를 앉고 들어갔는데 죄다 예약 불가능한 좌석이면 마음이 너무 아픔…
    - 캐싱 적합하지 않음
- 예약가능한 좌석조회
    - 조회요청이 많음 : But 대기열로 API 요청 수 조절중
    - 자주 바뀌는 데이터
    - 데이터 정합성 중요도(상) :예약 가능한 좌석이라서 눌렀는데 이미 예약된 좌석이였고 이런 정보가 바로바로 업데이트 되지 않으면 사용자는 진짜 예약 가능한 좌석을 찾지못하고 예매 실패할 수 있음
    - 캐싱 적합하지 않음
- 예약 및 결제 / 포인트 충전
    - 예약, 결제는 대부분의 사용자가 한 번만 요청한다. → 캐시 히트율이 매우 낮을것으로 예상
    - 결제 요청은 특히 실시간성이 중요
    - 캐싱 적합하지 않음

캐싱 적용 시 실시간성, 데이터 일관성, 요청 횟수를 주요 기준으로 삼았다. 콘서트 목록 조회는 상대적으로 데이터 변경 빈도가 낮아 캐싱이 적합하며, 나머지 경우에는 실시간성 보장이 우선시되어 캐싱이 적합하지 않다고 판단하였다.  그래서 “콘서트 목록 조회” 에 대해서만 캐싱을 할 예정이다.

### **조회 캐싱 전략 비교: Read-Through와 Look-Aside (Lazy Loading)**

조회 캐싱을 위해 사용할 수 있는 주요 전략으로는 Read-Through와 Look-Aside (Lazy Loading)가 있다

### Read-Through

- **특징**: 조회 시 캐시를 먼저 확인하고, 미스 발생 시 자동으로 DB에서 데이터를 가져와 캐시에 저장한다.
- **장점**: 서비스 계층이 캐싱을 신경 쓰지 않고 조회 가능하며, 데이터베이스와 캐시 간 일관성이 자동 유지된다.
- **단점**: 서비스 외부에서 캐시 제어가 어렵고, 다른 레이어에서 데이터 갱신이 필요할 경우 부적합하다.

### Lazy Loading(Look Aside)

- **특징**: 캐시에 데이터가 없을 때마다 필요한 시점에만 DB에서 데이터를 가져와 캐시에 저장한다.
- **장점**: 필요할 때만 캐시에 로드하여 메모리 효율성이 높으며, 유연한 캐싱 관리가 가능하다.
- **단점**: 첫 요청에서 캐시 미스 시 응답이 느려질 수 있고, 자주 요청되지 않는 데이터에서는 캐싱 이점이 적다.

콘서트 목록은 자주 바뀌지 않는 데이터이며, 사용자 입장 시 가장 먼저 조회되는 정보로 캐시 히트율이 높을 것으로 예상된다. Lazy Loading 방식을 사용하면 필요한 시점에 데이터베이스의 최신 데이터를 캐시에 적재하므로 사용자가 요청할 때마다 최신 데이터를 조회할 수 있다. 또한, 콘서트 목록 조회 요청이 한꺼번에 몰리지 않을 것으로 예상되므로 캐시 미스 시 데이터베이스에서 데이터를 가져와도 성능에 큰 부담이 없을 것이다. 
따라서 콘서트 목록 조회는 Lazy Loading 캐싱전략을 쓸것이다.
