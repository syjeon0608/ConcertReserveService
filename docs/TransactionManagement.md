# 분산환경에서의 트랜잭션 처리 문제와 해결
### 서비스 도메인 설명과 트랜잭션 범위 이해

- WaitingQueue: 대기열 관련 로직을 처리하는 서비스로, 대기열에 등록된 사용자들에 대한 상태 관리와 대기순번을 처리한다.
- Concert: 콘서트와 관련된 정보를 관리하는 서비스로, 콘서트, 스케줄, 좌석 조회와 예약을 처리한다.
- Payment: 결제와 관련된 로직을 처리하는 서비스로, 사용자가 예약한 콘서트에 대해 결제를 처리한다.
- User: 사용자와 관련된 로직을 처리하는 서비스로, 포인트 충전 및 사용을 관리한다.

결제 도메인을 제외한 다른 도메인 서비스는 독립적으로 트랜잭션을 관리하고 있다. 이 방식은 트랜잭션 범위를 최소화하여 성능 최적화와 병렬 처리를 유리하게 만든다. 각 도메인 서비스는 자체적인 책임을 관리하며, 트랜잭션 범위를 필요한 최소한으로 설정하여 불필요한 범위 확장을 피한다.

반면, 결제 서비스는 여러 도메인이 얽혀 있기 때문에, 하나의 트랜잭션 내에서 여러 작업을 처리해야 한다. 이로 인해 트랜잭션 범위가 커지고, 여러 작업을 하나의 트랜잭션으로 처리할 경우 트랜잭션 관리의 복잡성과 성능 문제를 야기할 수 있다. 또한 서비스가 확장되고 분리됨에 따라 이 문제는 더욱 심화될 수 있다.

```
public class PaymentFacade {
    @Transactional
    public PaymentInfo processPayment(Long reservationId, Long userId, String token) {
        좌석 검증();
        예약상태 변경();
        포인트사용()
        결제();
        return PaymentInfo;
    }
}
```

### 모놀로식 아키텍처 vs MSA

- 모놀로식 아키텍처 : 모든 서비스가 하나의 애플리케이션 내에서 실행되므로, 하나의 트랜잭션 범위 내에서 모든 서비스가 처리된다. 예를 들어, 결제, 포인트 사용, 좌석 예약 등 모든 작업을 하나의 트랜잭션 내에서 처리할 수 있다. 이 방식은 트랜잭션 관리가 간단하고, 서비스 간 의존성을 명확히 하여 트랜잭션 일관성을 보장하는 데 유리하다.

    - 장점
        - 트랜잭션 일관성을 유지하기 용이하다.
        - 하나의 데이터베이스와 하나의 JVM 내에서 실행되므로 트랜잭션 관리가 직관적이고 간단하다.
        - 서비스 간 의존성이 적고, 서비스 간 트랜잭션 관리가 쉽다.
    - 단점
        - 트랜잭션 범위가 커질수록 관리가 복잡해지고, 트랜잭션에 관련된 모든 서비스가 하나의 트랜잭션을 공유하기 때문에 성능 저하가 발생할 수 있다.
        - 서비스가 확장될 경우, 트랜잭션 관리와 스케일링이 어려울 수 있다.

      
- MSA : 각 서비스가 독립적인 애플리케이션으로 실행되며, 서로 다른 데이터베이스와 서로 다른 JVM에서 실행될 수 있다. 각 서비스가 독립적인 트랜잭션을 관리할 수 있어 성능 최적화와 병렬 처리가 가능하고, 서비스 간 결합도가 낮아져 확장성을 극대화할 수 있다.
    - 장점
        - 서비스 간 결합도가 낮고, 각 서비스는 자체적인 스케일링이 가능하다.
        - 유지보수와 확장성에 유리하다.

  - 단점
    - 서비스 간 통신이 복잡해지며, 트랜잭션 일관성을 보장하는 것이 어려워질 수 있다.
    - 분산 트랜잭션을 관리하기 위한 추가적인 복잡성이 발생한다.

### 분산 트랜잭션 문제

MSA 환경에서는 각 서비스가 독립적인 트랜잭션을 관리하고, 서로 다른 데이터베이스에서 트랜잭션을 처리하므로, 트랜잭션을 하나로 묶는 방식을 사용할 수 없다.  예를 들어, 결제 서비스에서 결제를 처리하고, 포인트 서비스에서 포인트를 차감하는 과정이 있을 때, 각 서비스는 서로 다른 트랜잭션을 관리하므로, 하나의 트랜잭션 내에서 이들 작업을 처리하는 것이 불가능하다.

```
1. 결제 서비스에서 결제는 성공적으로 처리되었고, 트랜잭션은 커밋되었다.
2. 포인트 서비스에서 포인트 차감 작업이 실패했지만, 결제 서비스에서의 트랜잭션은 롤백되지 않는다.
3. 이로 인해 결제는 완료되었지만 포인트는 차감되지 않는 상태가 발생한다.
4. 서비스 간 불일치가 발생하며, 트랜잭션 일관성을 보장하는 것이 매우 어려워진다.
```

각 서비스가 독립적인 트랜잭션을 관리하므로 트랜잭션 실패가 발생하면 서비스 간 데이터 불일치를 초래할 수 있다.
하나의 서비스에서 트랜잭션이 실패하면 그 서비스의 트랜잭션만 롤백되고 다른 서비스의 트랜잭션에는 영향을 미치지 않는다. 따라서, 서비스 간 일관성을 유지하기 위해서는 분산 트랜잭션 관리가 필수적이다.

### SAGA 패턴

SAGA 패턴은 분산 트랜잭션을 관리하고, 각 서비스가 독립적인 트랜잭션을 처리하면서도 트랜잭션 일관성을 유지할 수 있도록 해주는 기법이다. SAGA 패턴에서는 각 서비스가 트랜잭션을 처리한 후 실패 시 보상 트랜잭션을 실행하여 이전 작업을 취소하고 일관성 있는 상태로 복구할 수 있다.

SAGA 패턴의 두 가지 방식

1. 오케스트레이션 방식 (Orchestration): 중앙 서비스가 각 서비스의 트랜잭션 흐름을 조정하고, 실패 시 보상 트랜잭션을 실행한다.
2. 코디네이션 방식 (Choreography): 각 서비스가 독립적으로 트랜잭션을 처리하고, 실패 시 보상 트랜잭션을 실행하여 롤백한다.

### 아웃박스 패턴

아웃박스 패턴은 MSA에서의 트랜잭션 일관성을 보장하기 위해 이벤트 기반 처리를 사용하는 패턴이다. 이 패턴을 사용하면, 서비스 간에 메시지를 비동기적으로 전달하고, 트랜잭션 롤백 시에는 보상 이벤트를 통해 상태를 복구할 수 있다. 분산 트랜잭션을 보다 효율적으로 처리할 수 있게 된다.

### 결론

현재 모놀리식 아키텍처에서는 하나의 트랜잭션 범위 내에서 모든 서비스가 처리되기 때문에, 트랜잭션 관리가 비교적 간단하고 서비스 간 의존성을 명확히 할 수 있다. 그러나 서비스가 확장되면 여러 도메인 서비스들이 독립적인 애플리케이션으로 분리되고, 각 서비스가 독립적인 트랜잭션을 관리하게 된다. 이때 발생할 수 있는 분산 트랜잭션 문제와 트랜잭션 일관성을 관리하는 방법에 대한 고민이 필요하다.